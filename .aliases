#!/usr/bin/env bash
# vim: set filetype=sh

alias ..='cd ../'
alias ...='cd ../../'
alias ....='cd ../../../'
alias .....='cd ../../../../'
alias ......='cd ../../../../../'
alias dl='cd ~/Downloads/'
alias dt="cd ~/Desktop"
alias doc="cd ~/Documents"
alias proj='cd ~/projects/'
alias ll='ls -lah'
alias cl='clear'
alias :q='exit'
alias p='python3'
alias i='ipython'
alias g='git'
alias gti='git'
alias path='echo -e ${PATH//:/\\n}'
alias t='tmux new-session -s $(hostname)'
alias ta="tmux a"
td() {
    local dir
    dir=$(mktemp -d "/tmp/${1:+$1.}XXXXX") || return 1
    cd "$dir" || return 1
}
alias glb='git shortlog -nse'
alias git_clean='git branch | grep -v "main" | grep -v "master" | xargs git branch -D'

# fix annoying bug where the service does not restart correctly when switching between users
alias restart_anydesk='(tmux has-session -t anydesk_session 2>/dev/null || tmux new-session -d -s anydesk_session) && tmux send-keys -t anydesk_session "sudo killall anydesk && sudo anydesk --service" C-m && tmux attach -t anydesk_session'

# Think this is zsh default
alias ~='cd ~'

# Ramona Specific
if [ -f ~/dotfiles/ramona/.ramona ]; then
    source ~/dotfiles/ramona/.ramona
fi

if hash eza 2>/dev/null; then
    alias ls='eza'
    alias ll="eza -lah --git --icons"
    alias lll="eza -abghHliS@ --git --icons"
fi

alias la='cat ~/dotfiles/.aliases'

if hash bat 2>/dev/null; then
    alias la='bat ~/.aliases -l bash'
fi

alias lt='python3 ~/dotfiles/scripts/tmate_restore.py'

if hash nvim 2>/dev/null; then
    alias vim='nvim'
    alias vi='nvim'
    alias vimdiff='nvim -d'
fi

if command -v ffmpeg >/dev/null 2>&1 && command -v gifski >/dev/null 2>&1; then
    mp4togif() {
        input_file="$1"
        base_name="$(basename "${input_file}" .mp4)"
        ffmpeg -i "${input_file}" -f yuv4mpegpipe - | gifski -Q 100 --extra -o "${base_name}.gif" -
    }
fi

mkworktrees() {
    local base="/home/clay/projects/temp_worktrees"
    local branch="$1"
    [ -z "$branch" ] && { echo "Usage: mkworktrees <branch>"; return 1; }

    local repo_root
    repo_root=$(git -C "$PWD" rev-parse --show-toplevel) ||
        { echo "Not inside a Git repo"; return 1; }
    cd "$repo_root" || return 1

    git show-ref --quiet "refs/heads/$branch" || git branch "$branch" || return 1

    local parent="$base/$branch"

    if [ -d "$parent/${branch}_1" ]; then
        echo "Warning: Worktrees for branch '$branch' already exist"
        read -p "Remove and recreate? (y/N) " -n 1 -r
        echo
        [[ $REPLY =~ ^[Yy]$ ]] || return 1
        rm -rf "$parent"
    fi

    mkdir -p "$parent" || return 1

    local temp_prompt
    temp_prompt=$(mktemp --suffix=.md)
    cat > "$temp_prompt" << 'EOF'
<!-- Enter your prompt below, will be stripped before passing to tool -->
EOF

    $EDITOR "$temp_prompt"

    local prompt
    # Remove HTML comments and empty lines
    prompt=$(sed '/^<!--.*-->$/d' "$temp_prompt" | grep -v '^[[:space:]]*$')
    rm "$temp_prompt"

    if [ -z "$prompt" ]; then
        echo "Aborted: No prompt provided"
        return 1
    fi

    git worktree prune

    for i in 1 2 3; do
        local dir="$parent/${branch}_$i"
        git worktree add --detach "$dir" "$branch"
    done

    for i in 1 2 3; do
        echo "$prompt" > "$parent/${branch}_$i/.prompt"
    done

    tmux has-session -t "$branch" 2>/dev/null || {
        tmux new-session -d -s "$branch" -c "$parent/${branch}_1" -n "${branch}_1"
        tmux send-keys -t "$branch":1 "claude --dangerously-skip-permissions --model opus \"\$(cat .prompt)\"" C-m

        tmux new-window -t "$branch":2 -c "$parent/${branch}_2" -n "${branch}_2"
        tmux send-keys -t "$branch":2 "codex \"\$(cat .prompt)\"" C-m

        tmux new-window -t "$branch":3 -c "$parent/${branch}_3" -n "${branch}_3"
        tmux send-keys -t "$branch":3 "claude --dangerously-skip-permissions --model sonnet \"\$(cat .prompt)\"" C-m

        echo "tmux session \"$branch\" ready with windows ${branch}_{1,2,3}"
    }

    cd "$parent" || return 1
}

apply-worktree() {
    local target_repo="$1"
    local source_dir
    source_dir="$(pwd)"

    if [[ -z "$target_repo" ]]; then
        if ! command -v fzf >/dev/null 2>&1; then
            echo "Usage: apply-worktree <target-repo>"
            return 1
        fi
        target_repo=$(find ~/projects ~/projects/ramona ~/git/forks -maxdepth 1 -type d 2>/dev/null | fzf --prompt="Select target repo: ")
        if [[ -z "$target_repo" ]]; then
            echo "No repository selected"
            return 1
        fi
    fi

    if ! git rev-parse --git-dir >/dev/null 2>&1; then
        echo "Error: Not in a git repository"
        return 1
    fi

    if ! (cd "$target_repo" && git rev-parse --git-dir >/dev/null 2>&1); then
        echo "Error: Target is not a git repository: $target_repo"
        return 1
    fi

    local unstaged_diff
    unstaged_diff=$(git diff)
    if [[ -n "$unstaged_diff" ]]; then
        echo "$unstaged_diff" | (cd "$target_repo" && git apply) || {
            echo "Warning: Some unstaged changes failed to apply"
        }
    fi

    local staged_diff
    staged_diff=$(git diff --cached)
    if [[ -n "$staged_diff" ]]; then
        echo "$staged_diff" | (cd "$target_repo" && git apply --cached) || {
            echo "Warning: Some staged changes failed to apply"
        }
    fi

    git ls-files --others --exclude-standard | while IFS= read -r file; do
        local target_file="$target_repo/$file"
        mkdir -p "$(dirname "$target_file")"
        cp -p "$source_dir/$file" "$target_file"
    done
}

extract() {
    local archive="$1"
    if [[ -f "$archive" ]]; then
        case "$archive" in
            *.tar.bz2)  tar xjf "$archive" ;;
            *.tar.gz)   tar xzf "$archive" ;;
            *.bz2)      bunzip2 "$archive" ;;
            *.rar)      rar x "$archive" ;;
            *.gz)       gunzip "$archive" ;;
            *.tar)      tar xf "$archive" ;;
            *.tbz2)     tar xjf "$archive" ;;
            *.tgz)      tar xzf "$archive" ;;
            *.zip)      unzip "$archive" ;;
            *.Z)        uncompress "$archive" ;;
            *)          echo "'$archive' cannot be extracted via extract()" ;;
        esac
    else
        echo "'$archive' is not a valid file"
        return 1
    fi
}
